## 27. 배열

자바스크립트에 배열이라는 타입은 존재하지 않는다.
배열은 객체 타입이다.

일반 객체와 배열을 구분하는 가장 명확한 차이: 값의 순서, length 프로퍼티
배열은 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조다.

### 자바스크립트의 배열은 배열이 아니다

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조
밀집 배열 => 접근 O(1) but 삽입, 삭제에서 효율 떨어짐

JS의 배열은 메모리 공간을 동일한 크기로 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 이다.
_희소 배열: 배열의 요소가 연속적으로 이어져 있지 않은 배열 `[,2,,4]`_

JS의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다. (해시 테이블로 구현된 객체)
인덱스로 요소에 접근하는데는 효율이 떨어지나, 요소를 삽입하거나 삭제하는 경우에는 높은 성능을 기대할 수 있다.
_모던 JS 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현하였다._

**JS에서 희소 배열이 가능해도 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.**

### 배열 생성

**배열 생성 방법**

1. 배열 리터럴
2. Array 생성자 함수
3. Array.form
4. Array.of

#### Array 생성자 함수

- 전달된 인수가 1개이고 숫자인 경우

```js
const arr = new Array(10); // [empty * 10]
```

이때 생성된 배열은 희소배열이다.

- 전달된 인수가 없는 경우

```js
const arr = new Array(); // []
```

빈 배열을 생성한다.

- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우

```js
const arr = new Array(1, 2, 3); // [1, 2, 3]
```

인수를 요소로 갖는 배열을 생성한다.

<br>

_Array 생성자 함수는 new 연산자와 함께 호출하지 않더라도 생성자 함수로 동작한다._

#### Array.from

유사 배열 객체 또는 이터러블 객체를 인수로 전달 받아 배열로 변환하여 반환한다.

```js
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: "a", 1: "b" }); // ["a", "b"]

// 이터러블을 변환하여 배열을 생성한다.
Array.from("Hello"); // ["H", "e", "l", "l", "o"]
```

Array.from을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.
첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달하면서 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```js
Array.from({ length: 3 }, (_, idx) => i); // [0, 1, 2]
```

_유사 배열 객체의 조건_

1. 배열처럼 인덱스로 프로퍼티에 접근 가능
2. length 프로퍼티를 갖는 객체

_이터러블 객체의 조건_

1. for...of 문으로 순회 가능
2. 스프레드 문법과 배열 구조 분해 할당의 대상으로 사용할 수 있는 객체

#### Array.of

전달된 인수를 요소로 갖는 배열

```js
Array.of(1); // [1]
```

### 배열 요소의 참조

배열의 요소를 참조할 때는 대괄호 표기법을 사용한다. (배열은 객체다.)
존재하지 않는 요소에 접근하면 undefined를 반환한다.

### 배열 요소의 삭제

배열은 객체이기 때문에 delete 연산자를 사용할 수 있다.
하지만 delete 연산자는 length 프로퍼티에 영향을 주지 않기 때문에 배열이 희소 배열이 된다.

### 배열 메서드

배열에는 원본 배열을 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.

ES5부터 도입된 배열 메서드는 대부분 원본 배열을 직접 변경하지 않지만 초창기 배열 메서드는 원본 배열을 직접 변경하는 경우가 많다.
원본 배열을 직접 변경하는 메서드는 **외부 상태를 직접 변경하는 부수 효과**가 있으므로 주의해야 한다. 따라서 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 것이 좋다.

#### Array.isArray

전달된 인수가 배열인지에 따라 boolean 값을 반환한다.

#### Array.prototype.indexOf

인수로 전달한 요소를 배열에서 검색하여 인덱스를 반환한다.

- 첫 번째로 검색된 요소의 인덱스를 반환한다.
- 인수로 전달한 요소가 존재하지 않으면 -1을 반환한다.

#### Array.prototype.push(원본 배열 변경)

인수로 전달받은 **모든 값**을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티를 반환한다.

```js
// push 메서드 대체
// 스프레드 문법 사용
const newArr = [...arr, 3];
```

#### Array.prototype.pop(원본 배열 변경)

마지막 요소를 제거하고 제거한 요소를 반환한다.

#### Array.prototype.unshift(원본 배열 변경)

인수로 전달받은 모든 값을 원본 배열의 선두에 추가하고 변경된 length 프로퍼티를 반환한다. (push 메서드와 반대)

#### Array.prototype.shift(원본 배열 변경)

첫 번째 요소를 제거하고 제거한 요소를 반환한다. (pop과 반대)

shift 메서드와 push 메서드를 사용하면 큐를 쉽게 구현할 수 있다.
배열의 선두 부분이 데이터가 나가는 부분, 배열의 마지막 부분이 데이터가 들어오는 부분

#### Array.prototype.concat

인수로 전달된 값들(**배열** 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 **반환**한다.

결론적으로 push/unshift 메서드와 concat 메서드를 사용하는 대신 ES6의 스프레드 문법을 일관성 있게 사용하는 것을 권장한다.

#### Array.prototype.splice(원본 배열 변경)

원본 배열을 편집하는 경우 사용한다.
제거한 요소를 반환한다.

```js
array.splice(startIdx, deleteCount, [...items]);
```

#### Array.prototype.slice

인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다.

```js
array.slice(startIdx, endIdx);
```

#### Array.prototype.join

원본 배열의 모든 요소를 문자열로 변환한 후 인수로 전달받은 문자열, 즉 구분자로 연결한 문자열을 반환한다. 구분자는 생략 가능하며 기본 구분자는 `,`다.

#### Array.prototype.reverse(원본 배열 변경)

원본 배열의 순서를 반대로 뒤집는다.
반환값은 변경된 배열이다.

#### Array.prototype.fill(원본 배열 변경)

인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다.

```js
const arr = new Array(10).fill(0);
```

두 번째 인수로 요소를 채우기 시작할 인덱스와 채우기를 멈출 인덱스를 전달할 수 있다.

#### Array.prototype.includes

배열 내에 특정 요소가 포함되어 있는지 확인하여 boolean 값을 반환한다.
두 번째 인수로 검색을 시작할 인덱스를 전달할 수 있다. (음수를 전달할 수 있다.)

#### Array.prototype.flat

인수로 전달한 깊이만큼 재귀적으로 배열을 **평탄화**한다.
평탄화할 깊이를 인수로 전달할 수 있다.
Infinity를 전달하면 중첩 배열 모두를 평탄화한다.

### 배열 고차 함수

고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다.
고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.
즉 함수형 프로그래밍이란 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라고 할 수 있다.

#### Array.prototype.sort(원본 배열 변경)

기본적으로 유니코드 기반 오름차순 정렬이기 때문에
숫자 요소를 정렬하는 경우 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.
비교 함수는 양수나 음수 0을 반환해야 한다.

**비교 함수의 반환값**

- 0이거나 음수인 경우: 첫 번째 인수를 우선하여 정렬
- 양수인 경우: 두 번째 인수를 우선하여 정렬

#### Array.prototype.forEach

forEach 메서드를 통해 조건문과 반복문을 제거하고 변수의 사용을 억제할 수 있다.

희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.

#### Array.prototype.map

콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.

#### Array.prototype.filter

콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.

#### Array.prototype.reduce

인수로 전달받은 콜백 함수를 반복 호출하고, 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 **하나의 결과값**을 만들어 반환한다.

**reduce 활용**

- 평균 구하기

```js
const values = [1, 2, 3, 4, 5];
const average = values.reduce((a, c, idx) => {
  return i === values.length - 1 ? (a + c) / values.length : a + c;
}, 0);
```

- 요소의 중복 횟수 구하기

```js
const fruits = ["banana", "apple", "orange", "orange", "apple"];

const count = fruits.reduce((a, c, idx) => {
  a[c] = (a[c] || 0) + 1;
}, {});
```

#### Array.prototype.some / every

some: 조건을 만족하는 요소가 하나라도 있는지
만족하는 요소가 발견된다면 true를 반환하고 반복 종료

every: 조건을 만족하지 않는 요소가 하나라도 있는지
만족하지 않는 요소를 발견한다면 false를 반환하고 반복 종료

#### Array.prototype.find / findIndex

find: 인수로 전달한 콜백 함수를 호출하면서 반환값이 true인 첫 번째 요소를 반환
findIndex: 인수로 전달한 콜백 함수를 호출하면서 반환값이 true인 첫 번째 요소의 인덱스를 반환
